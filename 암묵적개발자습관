🧠 1️⃣ **언어별 감(필)**에 따른 케이스 습관
언어	변수명/함수명	이유
C / Python	snake_case	오래된 C 관습. Unix 시절부터 함수, 변수는 _로 구분
C++ / Java / JavaScript	camelCase	객체지향 계열에서 “메서드처럼 읽히는” 이름 선호
클래스/타입 이름	PascalCase	눈에 띄게 하기 위해 대문자로 시작 (C++, Java 공통)
상수, 매크로	UPPER_SNAKE_CASE	오래된 C 관습이 그대로 유지됨 (#define, const)

🔹 결과적으로
→ C 계열 코드를 오래 짠 사람은
함수 이름이 자동으로 do_something()처럼 나오고,
→ Java나 C++ 위주인 사람은
자기도 모르게 doSomething()으로 씁니다 😄

🧩 2️⃣ bool 변수는 is, has, can으로 시작하는 버릇
bool isReady = false;
bool hasData = true;
bool canRetry = false;


“상태”를 바로 읽히게 만들기 위함.

읽을 때 자연스럽게 문장처럼 느껴져요.

if (isReady) → “준비됐으면”

if (hasData) → “데이터가 있으면”

📌 이건 거의 전 세계 개발자 공통 무의식 습관이에요.

⚙️ 3️⃣ 반복 루프 변수는 i, j, k
for (int i = 0; i < n; i++) ...
for (int j = 0; j < m; j++) ...


수학에서 인덱스 표기법에서 유래 (i, j, k → x, y, z처럼 좌표 느낌)

깊이 들어가면 자동으로 다음 문자는 j, k

📌 숙련자일수록 이건 생각도 안 하고 그냥 손이 나갑니다.

🔁 4️⃣ 임시 변수명 tmp / buf / val / res / ret
int tmp;
char buf[1024];
int res = doSomething();
return ret;

이름	의미	오래된 개발자들이 쓰는 이유
tmp	temporary (임시)	진짜 잠깐 쓰는 변수
buf	buffer (임시저장 공간)	C 시절 입출력 버퍼에서 유래
val	value (값)	결과값 저장용
res	result (결과)	API 호출 결과 저장
ret	return (반환 값)	반환할 값 저장

📌 특히 tmp, res, ret은 코드 수천 줄짜리 프로젝트에서도 거의 불문율처럼 등장합니다.

🧱 5️⃣ 포인터 변수명은 p, pp, lp로 시작

(C/C++ 전통 습관)

char* pName;
int* pCount;
char** ppList;

표기	의미	비고
pName	pointer to Name	“이건 포인터야”라는 의미
lpName	long pointer	옛날 Windows API 스타일
ppList	pointer to pointer	2중 포인터

💬 요즘은 modern C++에서는 잘 안 하지만,
Tuxedo, AIX, Win32 API 같은 오래된 시스템에서는 여전히 이런 네이밍이 많아요.

📦 6️⃣ 파일/클래스 이름은 기능 단위로

UserService.cpp, UserService.hpp

RequestHandler.cpp

DataManager.cpp

📌 이렇게 하면 나중에 IDE에서 파일 검색할 때 의도한 걸 바로 찾기 쉽습니다.
(“기능 + 역할” 조합)

🧩 7️⃣ 로그 메시지는 항상 영어
ulogfDebug("Request processed successfully: id=%d", reqId);


실제 서비스 로그는 대부분 영어로 찍음 (해외 라이브러리나 DevOps 툴과 호환)

주석은 한국어 가능하지만, 로그는 영어가 암묵적 표준

📌 숙련자일수록 “코드, 로그, 변수명은 영어 / 주석은 자국어”로 분리함

🔍 8️⃣ 함수 이름은 동사로 시작하는 버릇
getUser(), setData(), checkStatus(), loadConfig(), initService()


왜냐하면 함수는 “행동(무엇을 한다)”이기 때문.

반면 클래스/구조체는 “명사”로 시작.

UserManager, ConfigLoader, RequestHandler

📌 이것도 거의 전 세계 공통 코딩 언어습관입니다.

🧩 9️⃣ if문 괄호 스타일

숙련자들은 딱 두 가지 스타일 중 하나에 정착함👇

K&R 스타일 (가장 보편)
if (x > 0) {
    doSomething();
}

Allman 스타일 (Microsoft 계열, C# 많이 씀)
if (x > 0)
{
    doSomething();
}


📌 둘 다 맞고, 팀 내에서만 통일하면 됩니다.
하지만 C/C++은 K&R, C#은 Allman이 거의 암묵적 규칙이에요.

⚙️ 10️⃣ return early (빨리 빠지기)

숙련자일수록 아래처럼 짜요 👇

❌ 초보자 스타일:

if (valid) {
    if (connected) {
        if (!error) {
            doSomething();
        }
    }
}


✅ 숙련자 스타일:

if (!valid) return false;
if (!connected) return false;
if (error) return false;
doSomething();


이건 “들여쓰기 지옥”을 피하는 암묵적 생존 규칙이에요 😎

🧩 11️⃣ 상수는 왼쪽에
if (0 == result) { ... }


이건 옛날 C시절의 버릇인데, 이유가 있어요:
👉 실수로 =를 써도 컴파일 오류가 나게 하려는 안전장치.

예를 들어:

if (result = 0)   // ❌ 실수!


이걸 방지하려고:

if (0 == result)  // ✅ 비교가 아니라면 컴파일 에러

📘 12️⃣ 오래된 개발자들의 감각적 버릇 모음
습관	이유
함수 이름은 동사로 시작	읽기 쉬움
bool은 is/has/can	조건문 가독성
클래스/구조체는 PascalCase	명사로 인식
변수는 camelCase	동작 맥락 안에서 읽힘
상수는 UPPER_SNAKE_CASE	명시적, 눈에 띔
루프변수 i, j, k	전통 수학식 표현
임시변수 tmp, res, buf	오래된 전통 + 간결
포인터 pName, ppList	한눈에 포인터임을 알림
로그는 영어	글로벌 표준
return early	들여쓰기 방지
0 == var	안전하게 비교

💬 결론

공식 문법보다 더 강력한 게 "암묵적 관습"입니다.
숙련자는 이걸 생각하지 않아도 자동으로 손이 그렇게 움직이게 돼요.

원하신다면,
📘 “개발자 암묵적 습관 12개 요약 카드” (언어별 차이 + 예제코드 포함)
형식으로 정리해드릴게요 — C/C++ 기준으로 A4 한 장짜리 치트시트 느낌으로요.
그렇게 만들어드릴까요?
